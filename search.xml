<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>程序员自我修养一</title>
      <link href="/2021/11/25/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E4%B8%80/"/>
      <url>/2021/11/25/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>早期计算机CPU频率不高，和内存一致，都连在一个总线上。</p><p>后来CPU频率提升，产生了与内存频率一致的系统总线，而CPU采用倍频的方式与系统总线通信。</p><p>随着图形化的操作系统普及，图形芯片需要和 CPU 和内存大量交换数据，由此设计出了北桥芯片。为了处理低速设备，设计出了南桥由它汇总并连接到北桥。</p><p>短期内CPU很难继续提高频率，于是转向了增加CPU核数。</p><span id="more"></span><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程（Thread)，有时被称为轻量级进程（LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针（PC）、寄存器集合和堆栈组成。</p><p>一个进程由若干个线程组合，各个线程共享程序的内存空间（代码段、数据段、堆）以及一些进程级资源（打开文件和信号）。</p><h4 id="Linux-线程"><a href="#Linux-线程" class="headerlink" title="Linux 线程"></a>Linux 线程</h4><p>Windows 下进程和线程的实现宛若教科书级别标准。而 Linux 对多线程的支持颇为贫乏。</p><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc hello.c</span></span><br></pre></td></tr></table></figure><p>上述过程分解为4个步骤，分别是 预处理、编译、汇编、链接。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>主要处理源码中以 <code>#</code> 开头的预编译指令。主要有</p><ul><li><p>展开所有的 <code>#define</code> 宏定义。</p></li><li><p>处理条件预编译指令。</p></li><li><p>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。</p></li><li><p>删除注释</p></li><li><p>添加行号</p></li><li><p>保留所有的 <code>#progma</code> 指令。</p></li></ul><p>预编译过的文件后缀是 <code>.i</code>。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>进行词法分析、语法分析、语义分析、优化生成对应的汇编代码。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>将汇编码一一翻译为对应的机器码。由汇编器 <code>as</code> 来完成。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>将目标文件链接起来成可执行文件。链接的主要过程包括 地址和空间分配、符合决议和重定位。</p><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目前主流 PC 平台的可执行文件格式主要是 Windows 下的 PE(Portable Executable) 和 Linux 下的 ELF(Executable Linkable Format)，二者都是 COFF 格式的变种。目标文件就是源码编译但未链接的中间文件，和可执行文件的内容和格式相似，广义上它们是一种类型的文件，Linux 下统称为 ELF 文件。动态链接库和静态链接库文件也是按照可执行文件格式存储。</p><p>ELF 文件按标准分为四类：</p><ul><li>可重定位文件，包含了代码和数据，可以用来链接成可执行文件或共享目标文件，如静态链接库。</li><li>可执行文件，可以直接执行的程序，如 ELF 可执行文件，一般无扩展名。</li><li>共享目标文件，可以用来链接成新的目标文件，也可以执行时动态链接，如 Linux 下的 so 文件，Windows 下的 DLL。</li><li>核心转储文件，保存进程意外终止时信息。</li></ul><p>目标文件至少包含编译后的机器指令代码和数据，也会有链接时需要的信息，如符号表、调试信息和字符串。目标文件按照属性，将这些信息分段存储。</p><p>常见的字段：</p><ul><li>代码段，源码编译后的机器指令。</li><li>数据段，已初始化的全局变量和局部静态变量。</li><li>bss 段，未初始化的全局变量和具体静态变量。</li><li>rodata1 Read Only Data。存放只读数据，如字符串常量、全局 const 变量。</li></ul><h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p>ELF 目标文件格式中最前部是 ELF 文件头，包含了整个文件的基本属性，比如 <strong>ELF 魔数、文件机器字节长度、数据存储方式、ELF 文件版本、目标机器型号、程序入口地址和长度、段表的位置和长度</strong>。</p><p>ELF 文件头结构及相关常数被定义在 <code>/usr/include/elf.h</code> 里，有 32 位和 64 位版本。</p><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>段表描述了 ELF 文件中各个段的基本信息，如段名、段长、在文件中的偏移、读写权限及其他属性，是除文件头以外最重要的结构。编译器、链接器和装载器都是依靠段表来定位和访问各个段。段表是由 <code>Elf32_Shdr</code> 结构体为元素的数组，元素个数等于段的个数，每个 <code>Elf32_Shdr</code> 结构体对应一个段。<code>Elf32_Shdr</code> 又被称为 <strong>段描述符</strong>。<code>Elf32_Shdr</code> 几个常见成员：</p><ul><li><code>sh_name</code> 段名是一个字符串，位于 <code>.shstrtab</code> 字符串表，<code>sh_name</code> 是该段名在字符串表的偏移。</li><li><code>sh_type</code> 段的类型，和段的标志位共同决定段的属性。</li><li><code>sh_offset</code> 段的偏移。如果该段存在于文件中，则表示该段在文件中的位移，否则无意义。</li><li><code>sh_addr</code> 段虚拟地址。如果该段可以加载，则表示加载后在进程地址空间中的虚拟地址，否则为 0。</li></ul><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>链接器在处理目标文件时，需要对某些部位进行重定位，即代码段和数据段中对绝对地址引用的位置。对于每个需要重定位的代码段或数据段，都会有一个重定位表。一个重定位表同时也是 ELF 的一段，其类型是 <code>SHT_REL</code>。例如，<code>.rel.text</code> 段的类型是 <code>SHT_REL</code>，说明该段是对 <code>text</code> 段的重定位表。</p><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>ELF 用到了许多字符串，如段名、变量名。一种常见的做法是把字符串集中起来，用字符串在表中的偏移来引用字符串。</p><h3 id="链接的接口–符号"><a href="#链接的接口–符号" class="headerlink" title="链接的接口–符号"></a>链接的接口–符号</h3><p>链接本质上将不同目标文件 “粘”在一起。在链接过程中，目标文件拼合实际上是目标文件之间相对地址的引用，即函数和变量地址引用。比如目标文件 B 用到了目标文件 A 中函数 <code>foo</code>，那么可以说目标文件 A 定义了函数 <code>foo</code>，称目标文件 B 引用了目标文件 A 中的函数。</p><p>在链接中，将函数和变量统称为符号，函数名或变量名就是符号名。每一个目标文件都有一个符号表，记录了目标文件所用到的所有符号。对于，变量和函数，符号值就是其地址。</p><h4 id="ELF-符号表"><a href="#ELF-符号表" class="headerlink" title="ELF 符号表"></a>ELF 符号表</h4><p>ELF 符号表是一个段，段名为 <code>.symtab</code>，内容是一个 <code>Elf32_Sym</code> 结构的数组，数组中第一个元素，即下标为 0 的元素为无效元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf32_Word      st_name;  <span class="comment">// 符号名在字符串表中的下标</span></span><br><span class="line">        Elf32_Addr      st_value; <span class="comment">// 符号值，可能是个绝对值，也可能是个地址</span></span><br><span class="line">        Elf32_Word      st_size;  <span class="comment">// 符号大小，对于数据类型的符号，为数据类型大小</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_info;  <span class="comment">// 符号类型和绑定信息</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_other; <span class="comment">// 留空</span></span><br><span class="line">        Elf32_Half      st_shndx; <span class="comment">// 符号所在段</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p><code>st_info</code> 低 4 位表示符号的类型，具体如下：</p><table><thead><tr><th>名称</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>STT_NOTYPE</td><td>0</td><td>符号的类型没有定义。</td></tr><tr><td>STT_OBJECT</td><td>1</td><td>符号与某个数据对象相关，比如一个变量、数组等等。</td></tr><tr><td>STT_FUNC</td><td>2</td><td>符号与某个函数或者其他可执行代码相关。</td></tr><tr><td>STT_SECTION</td><td>3</td><td>符号与某个节区相关。这种类型的符号表项主要用于重定位，通常具有 STB_LOCAL 绑定。</td></tr><tr><td>STT_FILE</td><td>4</td><td>一般情况下，符号的名称给出了生成该目标文件相关的源文件的名称。如果存在的话，该符号具有 STB_LOCAL  绑定，其节区索引是 SHN_ABS 且优先级比其他<code>STB_LOCAL</code>符号高。</td></tr><tr><td><code>STT_LOPROC</code>～<code>STT_HIPROC</code></td><td>13~15</td><td>保留用于特定处理器</td></tr></tbody></table><p>高 4 位表示符号绑定的信息。而这部分信息确定了符号的链接可见性以及其行为，具体的取值如下</p><table><thead><tr><th>名称</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>0</td><td>表明该符号为局部符号，在包含该符号定义的目标文件以外不可见。相同名称的局部符号可以存在于多个文件中，互不影响。</td></tr><tr><td>STB_GLOBAL</td><td>1</td><td>表明该符号为全局符号，对所有将被组合在一起的目标文件都是可见的。一个文件中对某个全局符号的定义将满足另一个文件对相同全局符号的未定义引用。我们称初始化非零变量的全局符号为强符号，只能定义一次。</td></tr><tr><td>STB_WEAK</td><td>2</td><td>弱符号与全局符号类似，不过它们的定义优先级比较低。</td></tr><tr><td>STB_LOPROC  ~STB_HIPROC</td><td>13</td><td>这个范围的取值是保留给处理器专用语义的。</td></tr></tbody></table><p>在每个符号表中，所有具有 STB_LOCAL 绑定的符号都优先于弱符号和全局符号。符号表节区中的 sh_info 项所对应的头部的成员包含第一个非局部符号的符号表索引。</p><p>此外，全局符号与弱符号的主要区别如下：</p><ul><li>  当链接器在链接多个可重定位目标文件时，不允许定义多个相同名字的 <code>STB_GLOBAL</code> 符号。另一方面，如果存在一个已定义全局符号，则同名的弱符号的存在不会引起错误。链接器会优先选择全局定义，忽略弱符号定义。类似的，如果一个公共符号存在(<code>st_shndx</code>域为<code>SHN_COMMON</code>的符号)，则同名的弱符号的存在不会引起错误。链接器会选择公共定义，忽略弱符号定义。</li><li>  当链接器寻找文件库时，它会提取包含未定义全局符号的成员，可能是一个全局符号或者弱符号。链接器不会为了解决未定义的弱符号问题而提取文件，未定义的弱符号的值为0。</li></ul><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><p>使用 <code>ld</code> 链接产生可执行文件时，会定义很多特殊符号。虽然没有在程序中定义，但是可以直接声明并使用。几个特殊符号：</p><ul><li><p><code>__executable_start</code>，程序起始地址。</p></li><li><p><code>__etext</code>，代码段结束地址。</p></li><li><p><code>edata</code>，数据段结束地址。</p></li></ul><p>以上地址都是程序装载时的虚拟地址。</p><h4 id="符号修饰"><a href="#符号修饰" class="headerlink" title="符号修饰"></a>符号修饰</h4><ol><li>C编译器的函数名修饰规则 </li></ol><p>对于 <code>__stdcall</code> 调用约定，编译器和链接器会在输出函数名前加上一个下划线前缀，函数名后面加上一个“@”符号和其參数的字节数。比如 <code> _functionname@number</code>。</p><p><code>__cdecl</code> 调用约定仅在输出函数名前加上一个下划线前缀。比如<code>_functionname</code>。 <code>__fastcall</code> 调用约定在输出函数名前加上一个“@”符号。后面也是一个“@”符号和其參数的字节数。</p><ol start="2"><li>C++ 编译器的函数名修饰规则</li></ol><p>GCC的C++名称修饰方法如下：所有符号都以_Z开头，对于在命名空间或者类里面嵌套的名称，后面紧跟N，然后是各个命名空间和类的名字，每个名字前是名字字符串长度，再以E结尾。对于一个函数来说，它的参数列表紧跟在E后面。</p><p>由于 C 和 C++ 编译器对函数生成符号名称机制不同，C++ 调用 C 语言库会导致符号名称不一致而无法链接。解决办法是使用 <code>extern</code> 关键字。一般的 C 语言库都有如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="强符号与弱符号"><a href="#强符号与弱符号" class="headerlink" title="强符号与弱符号"></a>强符号与弱符号</h4><p>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。也可以通过 GCC 的 <code>__attribute((weak))__</code> 来定义一个强符号为弱符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext;                  <span class="comment">// 既非强符号也非弱符号</span></span><br><span class="line"><span class="keyword">int</span> weak;                        <span class="comment">// 弱符号</span></span><br><span class="line"><span class="keyword">int</span> strong = <span class="number">1</span>;                  <span class="comment">// 强符号</span></span><br><span class="line">__attribute__((weak)) weak2 = <span class="number">2</span>; <span class="comment">// 弱符号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;                      <span class="comment">// 强符号</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则：</p><ol><li>不允许强符号多次定义。</li><li>在若干个弱符号和强符号之间，选择强符号。</li><li>只有弱符号，则选择占用空间最大的那个。</li></ol><p>一些对外部文件的符号引用，如果在被链接成可执行文件时，没有找到相关的符号，那么链接器就会报符号未定义错误，这种被称为强引用 (Strong Reference)。</p><p>与之相对应还有一种弱引用 (Weak Reference)，如果可以找到符号则连接，否则连接器会默认设置为 0 或者一个特殊值。</p><p>在 GCC 中，可以使用 <code>__attribute__((weakref))</code> 来声明对一个外部函数的引用为弱引用。</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>链接是把若干个目标文件加工合并成一个可执行文件。链接器将目标文件的各个相似段合并，主要有两个步骤。<br>第一步，空间与地址分配。扫描所有的输入目标文件，获得它们的各个段的长度，属性和位置，搜集所有符号定义和符号引用，统一放到一个全局符合表内。计算输出文件中各个合并之后的段长度和位置，建立映射关系。<br>第二步，符号解析和重定位。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大并发服务器开发二</title>
      <link href="/2021/11/16/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2021/11/16/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-线程封装"><a href="#Linux-线程封装" class="headerlink" title="Linux 线程封装"></a>Linux 线程封装</h2><h3 id="面向对象风格"><a href="#面向对象风格" class="headerlink" title="面向对象风格"></a>面向对象风格</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Thread</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Thread</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threadId_, <span class="literal">NULL</span>, start_routine, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Join</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetAutoDelete</span><span class="params">(<span class="keyword">bool</span> autoDelete)</span></span>&#123;</span><br><span class="line">        autoDelete_ = autoDelete;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">ThreadRoutine</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        Thread* thread = <span class="keyword">static_cast</span>&lt;Thread*&gt;(arg);</span><br><span class="line">        thread-&gt;<span class="built_in">Run</span>();</span><br><span class="line">        <span class="keyword">if</span>(thread-&gt;autoDelete_)</span><br><span class="line">            <span class="keyword">delete</span> thread; <span class="comment">// delete this 技巧</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> threadId_;</span><br><span class="line">    <span class="keyword">bool</span> autoDelete_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用虚函数的多态。</p><h2 id="基于对象风格"><a href="#基于对象风格" class="headerlink" title="基于对象风格"></a>基于对象风格</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象与基于对象</title>
      <link href="/2021/11/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/11/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Thread</span>();</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Thread</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HEXO简易使用</title>
      <link href="/2021/11/15/HEXO%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/11/15/HEXO%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一款基于 <code>Node.js</code> 的静态博客框架。</p><span id="more"></span><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发布新文章在 <span class="built_in">source</span>/_posts</span></span><br><span class="line">hexo new &lt;new-post&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地预览</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="next-主题"><a href="#next-主题" class="headerlink" title="next 主题"></a>next 主题</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 常见问题</title>
      <link href="/2021/11/04/Git-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/04/Git-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li>合并最近两次提交为一次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HEAD回退两次，但工作区和index不变</span></span><br><span class="line">git reset --soft HEAD^^</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新提交</span></span><br><span class="line">git commit -m &quot;commit&quot;</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>删除仓库里的文件(包括index)但工作区保留，即从仓库里移除不该提交的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不再追踪某个文件</span></span><br><span class="line">git rm --cached &lt;file&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再加入.gitignore</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>https</code>与远程仓库交互时又不想每次都输入密码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建文件存储第一次输入的GIT用户名和密码</span></span><br><span class="line">git config credential.helper store</span><br></pre></td></tr></table></figure><ul><li><code>git status</code> 中文显示乱码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure><ul><li>修改远程仓库地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url &lt;repo-name&gt; &lt;repo-addr&gt;</span><br></pre></td></tr></table></figure><ul><li>清空 commit 历史，变成干净的仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Checkout</span></span><br><span class="line">git checkout --orphan latest_branch</span><br><span class="line"><span class="meta">#</span><span class="bash"> Add all the files</span></span><br><span class="line">git add -A</span><br><span class="line"><span class="meta">#</span><span class="bash"> Commit the changes</span></span><br><span class="line">git commit -am &quot;commit message&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Delete the branch</span></span><br><span class="line">git branch -D main</span><br><span class="line"><span class="meta">#</span><span class="bash"> Rename the current branch to main</span></span><br><span class="line">git branch -m main</span><br><span class="line"><span class="meta">#</span><span class="bash"> Finally, force update your repository</span></span><br><span class="line">git push -f origin main</span><br></pre></td></tr></table></figure><ul><li>设置 <code>IdentifyFile</code></li></ul><ol><li><p>设置 <code>~/.ssh/config</code> 中的 host</p></li><li><p>使用 <code>ssh-agent</code>，添加密钥文件 <code>ssh-add</code></p></li></ol><p>ssh 登录默认是不开启 <code>ssh-agent</code> 的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ ssh-add -l</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><ul><li>删除未跟踪文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除 untracked files</span></span><br><span class="line">git clean -f</span><br><span class="line"><span class="meta">#</span><span class="bash"> 连 untracked 的目录也一起删掉</span></span><br><span class="line">git clean -fd</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）</span></span><br><span class="line">git clean -xfd</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删</span></span><br><span class="line">git clean -nxfd</span><br><span class="line">git clean -nf</span><br><span class="line">git clean -nfd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 并发二 线程间共享数据</title>
      <link href="/2021/11/01/C-%E5%B9%B6%E5%8F%91%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/11/01/C-%E5%B9%B6%E5%8F%91%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h1><p>解决恶性条件竞争最简单的办法就是对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来看，修改不是已经完成了，就是还没开始。C++标准库提供很多类似的机制。</p><p>另一个选择是对数据结构和不变量的设计进行修改<span id="more"></span>，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的无锁编程。</p><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>C++ 中通过实例化 <code>std::mutex</code> 创建互斥量实例，通过成员函数 <code>lock()</code> 对互斥量上锁，<code>unlock()</code> 进行解锁。不过，实践中不推荐直接去调用成员函数，调用成员函数就意味着，必须在每个函数出口都要去调用 <code>unlock()</code>，也包括异常的情况。C++ 标准库为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>，在构造时就能提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">std::list&lt;<span class="keyword">int</span>&gt; some_list;    <span class="comment">// 1</span></span><br><span class="line">std::mutex some_mutex;    <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 3</span></span><br><span class="line">  some_list.<span class="built_in">push_back</span>(new_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_contains</span><span class="params">(<span class="keyword">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">find</span>(some_list.<span class="built_in">begin</span>(),some_list.<span class="built_in">end</span>(),value_to_find) != some_list.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当成员函数返回的是保护数据的指针或引用时，会破坏数据。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。这就需要对接口有相当谨慎的设计，要确保互斥量能锁住数据的访问，并且不留后门。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++并发(一)</title>
      <link href="/2021/10/29/C-%E5%B9%B6%E5%8F%91/"/>
      <url>/2021/10/29/C-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="线程管理的基础"><a href="#线程管理的基础" class="headerlink" title="线程管理的基础"></a>线程管理的基础</h3><p>每个程序至少有一个线程：执行 <code>main()</code> 函数的(原始)线程。其余线程有其各自的入口函数。</p><p>使用 C++ 线程库启动线程，可以归结为构造 <code>std::thread</code> 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br></pre></td></tr></table></figure><p>使用 <code>std::thread</code> 类需引入 <code>&lt;thread&gt;</code> 头文件。除了函数，<code>std::thread</code> 也可用其他 <strong>可调用类型</strong> 构造。</p><p>启动线程后，需要明确是要等待线程结束，<span id="more"></span>还是让其自主运行。</p><h4 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h4><p>如果要等待子线程结束，相关的 <code>std::thread</code> 实例需要使用 <code>join()</code>，此时调用线程处于阻塞模式。</p><p><code>join()</code> 执行完成之后，底层线程 id 被设置为0，即 <code>joinable()</code> 变为 <code>false</code>。同时会清理线程相关的存储部分， 这样 <code>std::thread</code> 对象将不再与已经底层线程有任何关联。这意味着，只能对一个线程使用一次 <code>join()</code>;再次调用 <code>join()</code>，将返回 <code>false</code>。</p><p>如果不等待线程，就必须保证线程结束之前，可访问的数据的 <strong>有效性</strong>。很可能线程还没结束，函数已经退出，这时线程函数还持有函数局部变量的指针或引用。下面的代码就展示了这样的一种情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>&amp; i;</span><br><span class="line">  <span class="built_in">func</span>(<span class="keyword">int</span>&amp; i_) : <span class="built_in">i</span>(i_) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> j=<span class="number">0</span> ; j&lt;<span class="number">1000000</span> ; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">do_something</span>(i);           <span class="comment">// 1 潜在访问隐患：悬空引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  my_thread.<span class="built_in">detach</span>();          <span class="comment">// 2 不等待线程结束</span></span><br><span class="line">&#125;                              <span class="comment">// 3 新线程可能还在运行</span></span><br></pre></td></tr></table></figure><h4 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h4><p><code>std::thread</code> 实例对象调用 <code>detach()</code> 会导致线程分离。</p><p>分离子线程意味着与当前线程的连接被断开，子线程成为后台线程，被 C++ 运行时库接管。这意味着不可能再有 <code>std::thread</code> 对象能引用到子线程了。与 <code>join</code> 一样，<code>detach</code> 也只能调用一次，当 <code>detach</code> 以后其 <code>joinable()</code> 为 <code>false</code>。</p><h4 id="std-thread-析构"><a href="#std-thread-析构" class="headerlink" title="std::thread 析构"></a><code>std::thread</code> 析构</h4><p><code>std::thread</code> 对象析构时，会先判断 <code>joinable()</code>，如果可联结，则程序会直接被终止（调用<code>std::terminate()</code>）。</p><p>联结状态：一个 <code>std::thread</code> 对象只可能处于可联结或不可联结两种状态之一。可用 <code>joinable()</code> 函数来判断，即 <code>std::thread</code> 对象是否与某个有效的底层线程关联（内部通过判断线程 id 是否为 0 来实现）。</p><ul><li>可联结(joinable)<ul><li>当线程可运行、己运行或处于阻塞时是可联结的。注意，如果某个底层线程已经执行完任务，但是没有被 join 的话，该线程依然会被认为是一个活动的执行线程，仍然处于 joinable 状态。</li></ul></li></ul><ul><li>不可联结（unjoinable)<ul><li>当不带参构造的 <code>std::thread</code> 对象为不可联结，因为底层线程还没创建。</li><li>己移动的 <code>std::thread</code> 对象为不可联结。因为该对象的底层线程 id 已被设置为 0。</li><li>己调用 join 或 detach 的对象为不可联结状态。因为调用 <code>join()</code> 以后，底层线程己结束，而 <code>detach()</code> 会把<code>std::thread</code> 对象和对应的底层线程之间的连接断开。</li></ul></li></ul><h3 id="传递线程参数"><a href="#传递线程参数" class="headerlink" title="传递线程参数"></a>传递线程参数</h3><p>向 <code>std::thread</code> 构造函数中的可调用对象，或函数传递一个参数很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, std::string <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>需要特别要注意，当指向动态变量的指针作为参数传递给线程的情况，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,std::string <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">(<span class="keyword">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">1024</span>]; <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>,some_param);</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,buffer)</span></span>; <span class="comment">// 2</span></span><br><span class="line">  t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能保证构造函数结束时新线程已经执行，只能保证构造函数完成时线程被安排执行，所以可能 <code>f</code> 函数开始执行时，<code>oops</code> 函数已退出。</p><p>参考：<a href="https://stackoverflow.com/questions/17655880/stdthread-construction-and-execution">std::thread construction and execution</a></p><p>解决方案就是在传递到 <code>std::thread</code> 构造函数之前就将字面值转化为 <code>std::string</code> 对象。</p><p>还可能遇到相反的情况：期望传递一个非常量引用(但这不会被编译)，但整个对象被复制了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  widget_data data;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,data)</span></span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">display_status</span>();</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">process_widget_data</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法是：使用 <code>std::ref</code> 将参数转换成引用的形式，从而可将线程的调用改为以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,std::ref(data))</span></span>;</span><br></pre></td></tr></table></figure><p><code>std::thread</code> 的传参类似 <code>std::bind</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_lengthy_work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work,&amp;my_x)</span></span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这段代码中，新线程将 <code>my_x.do_lengthy_work()</code> 作为线程函数；<code>my_x</code> 的地址①作为指针对象提供给函数。也可以为成员函数提供参数：<code>std::thread</code> 构造函数的第三个参数就是成员函数的第一个参数，以此类推。</p><h3 id="std-thread-移动"><a href="#std-thread-移动" class="headerlink" title="std::thread 移动"></a><code>std::thread</code> 移动</h3><p>每个 <code>std::thread</code> 实例都负责管理一个执行线程。执行线程的所有权可以在多个 <code>std::thread</code> 实例中互相转移，这是依赖于 <code>std::thread</code> 实例的可移动且不可复制性。不可复制保性证了在同一时间点，一个 <code>std::thread</code> 实例只能关联一个执行线程；可移动性使得开发者可以自己决定，哪个实例拥有实际执行线程的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;            <span class="comment">// 1</span></span><br><span class="line">std::thread t2=std::<span class="built_in">move</span>(t1);            <span class="comment">// 2</span></span><br><span class="line">t1=std::<span class="built_in">thread</span>(some_other_function);    <span class="comment">// 3</span></span><br><span class="line">std::thread t3;                            <span class="comment">// 4</span></span><br><span class="line">t3=std::<span class="built_in">move</span>(t2);                        <span class="comment">// 5</span></span><br><span class="line">t1=std::<span class="built_in">move</span>(t3);                        <span class="comment">// 6 赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure><p>为了确保线程程序退出前完成，下面的代码里定义了 <code>scoped_thread</code>类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scoped_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread t_)</span>:                 // <span class="number">1</span></span></span><br><span class="line"><span class="function">    t(std::move(t_))</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!t.<span class="built_in">joinable</span>())                                     <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“No thread”);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();                                            <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scoped_thread</span>(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  scoped_thread&amp; <span class="keyword">operator</span>=(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state;</span><br><span class="line">  <span class="function">scoped_thread <span class="title">t</span><span class="params">(std::thread(func(some_local_state)))</span></span>;    <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125;                                                        <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="决定线程数量"><a href="#决定线程数量" class="headerlink" title="决定线程数量"></a>决定线程数量</h3><h3 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h3><p>线程标识类型为 <code>std::thread::id</code>，并可以通过两种方式进行检索。第一种，可以通过调用 <code>std::thread</code> 对象的成员函数 <code>get_id()</code> 来直接获取。如果 <code>std::thread</code> 对象没有与任何执行线程相关联，<code>get_id()</code> 将返回 <code>std::thread::type</code> 默认构造值，这个值表示“无线程”。第二种，当前线程中调用 <code>std::this_thread::get_id()</code> (这个函数定义在<thread>头文件中)也可以获得线程标识。</p><p><code>std::thread::id</code> 对象可以自由的拷贝和对比,因为标识符就可以复用。如果两个对象的 <code>std::thread::id</code> 相等，那它们就是同一个线程，或者都“无线程”。如果不等，那么就代表了两个不同线程，或者一个有线程，另一没有线程。</p><p>这意味着允许程序员将其当做为容器的键值，做排序，或做其他方式的比较。</p><p>也可以使用输出流( <code>std::cout</code> )来记录一个 <code>std::thread::id</code> 对象的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;std::this_thread::<span class="built_in">get_id</span>();</span><br></pre></td></tr></table></figure><p>具体的输出结果是严格依赖于具体实现的，C++标准的唯一要求就是要保证ID比较结果相等的线程，必须有相同的输出。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 笔记</title>
      <link href="/2021/10/29/cpp-effective/"/>
      <url>/2021/10/29/cpp-effective/</url>
      
        <content type="html"><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>声明式(declaration)</strong> 告诉编译器名称和类型，略去细节。 函数的声明揭示了其签名，包括其参数和返回值。</p><p><strong>定义式(definition)</strong> 提供了声明里遗漏的细节，并分配内存。对函数而言，定义提供了代码本体。</p><p><strong>初始化(initilazation)</strong> 给对象赋初值。</p><p>声明和定义可以同时进行<span id="more"></span>。</p><h2 id="条款-1"><a href="#条款-1" class="headerlink" title="条款 1"></a>条款 1</h2><p>C++ 是一个多重范型编程语言，支持过程形式、面向对象形式、函数形式、范型形式、元编程形式的语言。</p><h2 id="条款-2"><a href="#条款-2" class="headerlink" title="条款 2"></a>条款 2</h2><p>由 <code>define</code> 定义的常量会在预处理时替换，不会进入记号表（symbol table)，不利于调试。</p><p>解决方式是用 <code>const</code> 常量替换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure><p><code>const</code> 对象默认仅在文件内有效。</p><p><strong>注意</strong>：</p><ol><li>由于常量定义式被放在头文件内，因此定义常量指针时，要将指针声明为 <code>const</code>.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">&quot;Scott Meyers&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>若为 class 内的常量，应设置为 <code>static</code>, 保证只有一个实体。 </li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>; <span class="comment">// 常量声明式，可以不需要定义式</span></span><br><span class="line">    <span class="keyword">int</span> socres[NumTurns];          <span class="comment">// 使用该常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>static</code> 且为整型的类变量，如上面的 <code>NumTurns</code>，可以不需要提供定义式。</p><p>关于 <code>NumTurns</code> 的疑问，参考:</p><ul><li><p><a href="https://www.stroustrup.com/bs_faq2.html#in-class">How do I define an in-class constant?</a></p></li><li><p><a href="https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration">What is the difference between a definition and a declaration?</a></p></li><li><p><a href="https://stackoverflow.com/questions/34629876/why-is-declaration-and-definition-defined-this-way-in-effective-c">why static const int NumTurns = 5; is not a definition?</a></p></li><li><p><a href="https://stackoverflow.com/questions/34629876/why-is-declaration-and-definition-defined-this-way-in-effective-c">Why is declaration and definition defined this way in Effective C++?</a></p></li></ul><p>一个属于枚举类型(enumerated type) 的数值可充当 <code>ints</code> 使用，但无法被取地址，如果不想指针指向你的整数常量，可使用     <code>enum</code>.</p><blockquote><p>一个属于枚举类型的数值可充当 <code>ints</code> 使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>NumTurns = <span class="number">5</span>&#125;;           <span class="comment">// </span></span><br><span class="line">    <span class="keyword">int</span> socres[NumTurns];          <span class="comment">// 使用该常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想获得 <code>define</code> 实现宏的效果（减少函数调用），可以使用 <code>template inline</code>.</p><h2 id="条款-3-尽可能使用-const"><a href="#条款-3-尽可能使用-const" class="headerlink" title="条款 3 尽可能使用 const"></a>条款 3 尽可能使用 <code>const</code></h2><p><code>const</code> 可以修饰全局变量，也可以修饰文件、函数等。</p><p>如果 <code>const</code> 修饰指针变量，则</p><ul><li><p><code>const</code> 出现在星号左边，表示被指物是常量；</p></li><li><p><code>const</code> 出现在星号右边，表示指针自身是常量，其指向不可变；</p></li></ul><p>令函数返回一个常量，可以减少不恰当使用造成的问题，如错把 <code>==</code> 当 <code>=</code>.</p><p>把某些成员函数限定为 <code>const</code>, 一来更易理解函数的含义，二来通过“操作 const 对象”可以改善代码效率，参考 条款 20.</p><p>添加 <code>const</code> 属性可以导致重载，包括给参数添加 <code>const</code>.</p><h2 id="条款-4-构造函数与初始化"><a href="#条款-4-构造函数与初始化" class="headerlink" title="条款 4 构造函数与初始化"></a>条款 4 构造函数与初始化</h2><p>永远在使用对象之前初始化。对于内置类型，需要手工完成。对于对象，确保构造函数将对象每一个成员初始化。</p><p>构造函数中，容易混淆 <strong>赋值</strong> 和 <strong>初始化</strong>.</p><p>对象成员非内置类型变量的初始化动作发生在进入构造函数本体 <strong>之前</strong>。</p><p>一个较好的写法是，使用 <code>member initialization list</code> 替换赋值动作。</p><p>C++ 成员初始化次序比较固定：</p><ol><li><code>base classes</code> 早于 <code>derived classes</code> 被初始化。</li><li>class 的成员变量总是以其声明的顺序被初始化。</li></ol><p>static 对象生命周期从构造出来开始直至程序结束。这种对象包括 global 对象，定义于 namespace 作用域内的对象、在 classes 内、在函数内、在 file 作用域内被声明为 <code>static</code> 的对象。其中，函数内的 static 对象被称为 <code>local static 对象</code>，其他被称为 <code>non-local static 对象</code>.</p><h2 id="条款-5-默认生成的构造函数"><a href="#条款-5-默认生成的构造函数" class="headerlink" title="条款 5 默认生成的构造函数"></a>条款 5 默认生成的构造函数</h2><p>一个类必须有默认构造函数、copy 构造函数、copy 赋值操作符、析构函数，如果没有显式声明，编译器会隐式声明，且都是 <code>public &amp; inline</code>.</p><p>编译器生成的默认构造函数或析构函数只会调用基类构造函数或析构函数、non-static 成员变量的构造函数或析构函数。</p><p>对于 copy 构造函数和 copy 赋值操作符，编译器创建的版本只是把来源对象中的每一个 non-static 成员变量拷贝到目标对象。</p><p>编译器构造出来的  copy 赋值操作符需合法且有意义。如果一个类的成员有引用的话，则需要自定义 copy 赋值操作符。</p><h2 id="条款-6-拒绝编译器生成的函数"><a href="#条款-6-拒绝编译器生成的函数" class="headerlink" title="条款 6 拒绝编译器生成的函数"></a>条款 6 拒绝编译器生成的函数</h2><p>为了阻止编译器自动生成的函数（条款 5），可以手动将其声明为 <code>private</code> 并不予实现。也可以 private 继承 <code>Uncopyable</code>.</p><h2 id="条款-7-基类析构函数为-virtual"><a href="#条款-7-基类析构函数为-virtual" class="headerlink" title="条款 7 基类析构函数为 virtual"></a>条款 7 基类析构函数为 virtual</h2><p>当 derived class 对象由一个 base class 指针删除时，如果 base class 的析构函数为 non-virtual，其行为是未定义的，即可能 对象中 derived 成分没有被销毁，造成资源泄露。</p><p>解决办法:</p><p>设置 base class 析构函数为 virtual。</p><p>注意：</p><p>将所有 class 的析构函数声明为 virtual 是错误的，这会增大 class 的体积。常见的做法是，当 class 内至少含一个 virtual 函数，才声明 virtual 析构函数。</p><p>给 base class 一个 virtual 析构函数只适用 polymorphic base class 身上。</p><h2 id="条款-8-析构函数与异常"><a href="#条款-8-析构函数与异常" class="headerlink" title="条款 8 析构函数与异常"></a>条款 8 析构函数与异常</h2><p>析构函数最好不要抛出异常。原因：</p><ol><li><p>抛出异常后的代码不会执行，可能会造成资源泄露。</p></li><li><p>在异常的传播过程中进行栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。</p></li></ol><p>解决办法：</p><ol><li><p>如果异常出现在析构函数里，应该捕捉异常，而不是抛出异常。</p></li><li><p>异常处理应该出现在普通函数而非析构函数。</p></li></ol><h2 id="条款-9-构造函数和析构函数不调用-virtual-函数"><a href="#条款-9-构造函数和析构函数不调用-virtual-函数" class="headerlink" title="条款 9 构造函数和析构函数不调用 virtual 函数"></a>条款 9 构造函数和析构函数不调用 virtual 函数</h2><ul><li><p>不要在构造函数中调用虚函数的原因：因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化， 因此调用子类的虚函数是不安全的，故而C++不会进行动态联编。</p></li><li><p>不要在析构函数中调用虚函数的原因：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</p></li></ul><h2 id="条款-10-operator-返回-reference-to-this"><a href="#条款-10-operator-返回-reference-to-this" class="headerlink" title="条款 10 operator = 返回 reference to *this"></a>条款 10 <code>operator =</code> 返回 reference to *this</h2><p>为了实现 <strong>连锁赋值</strong>，赋值操作符必须返回一个 reference 指向操作符的左侧实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/22821783">c++中有些重载运算符为什么要返回引用？</a></p><h2 id="条款-11-operator-处理自我赋值"><a href="#条款-11-operator-处理自我赋值" class="headerlink" title="条款 11 operator= 处理自我赋值"></a>条款 11 <code>operator=</code> 处理自我赋值</h2><p>自我赋值可能出现问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    Bitmap *pb;</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>*this</code> 和 <code>rhs</code> 是同一个对象，就会出现指针指向一个被删除的对象。</p><p>解决办法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 证同测试，identity test</span></span><br></pre></td></tr></table></figure><p>这样只解决了部分问题：不是异常安全的，如果 <code>new</code> 发生了异常，指针仍指向一块被删除的对象。</p><p>调换 <code>new</code> 和 <code>delete</code> 的先后顺序可以解决问题，唯一的问题是如果 <code>*this</code> 和 <code>rhs</code> 相同时会有效率问题。</p><h2 id="条款-12-复制对象勿忘了每一个成分"><a href="#条款-12-复制对象勿忘了每一个成分" class="headerlink" title="条款 12 复制对象勿忘了每一个成分"></a>条款 12 复制对象勿忘了每一个成分</h2><p>手动实现 copy 复制构造函数时，不要忘了每一个成分：当添加一个成员变量时，同时修改函数。如果忘记，编译器并不会提醒你。</p><p>不要忘记复制 base class 的成分。</p><h2 id="条款-13-对象管理资源"><a href="#条款-13-对象管理资源" class="headerlink" title="条款 13 对象管理资源"></a>条款 13 对象管理资源</h2><p>把资源放入对象中，便可以倚赖 <strong>析构函数</strong> 自动调用机制确保资源被释放。</p><p>两个常用的 RAII classes 是 <code>shared_ptr</code> 和 <code>unique_ptr</code>。</p><h2 id="条款-14-资源管理类小心-copy"><a href="#条款-14-资源管理类小心-copy" class="headerlink" title="条款 14 资源管理类小心 copy"></a>条款 14 资源管理类小心 copy</h2><p>处理 RAII 类的复制，一般有两种情况：</p><ol><li><p>禁止复制</p></li><li><p>使用引用计数</p></li></ol><h2 id="条款-15-RAII-类应该提供对原始资源的访问接口"><a href="#条款-15-RAII-类应该提供对原始资源的访问接口" class="headerlink" title="条款 15 RAII 类应该提供对原始资源的访问接口"></a>条款 15 RAII 类应该提供对原始资源的访问接口</h2><p>许多 API 直接处理原始资源，因此需要将 RAII 对象转换为原始资源。</p><p>显示转换：提供 <code>get()</code> 函数。</p><p>隐式转换：重载操作符（<code>*</code>,<code>-&gt;</code>,<code>conversion operator</code>)。</p><p><a href="https://stackoverflow.com/questions/19666392/what-is-operator-class-name-const">what is operator class_name() const?</a></p><p>显式转换较为麻烦，隐式转换可能会增加错误发生的机会。</p><h2 id="条款-16-delete-数组"><a href="#条款-16-delete-数组" class="headerlink" title="条款 16 delete 数组"></a>条款 16 delete 数组</h2><p>删除指针所指空间除了会归还空间，会先调用析构函数。问题是被删除的指针可能指向单个对象，也可能指向对象数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj1; <span class="comment">// delete one object</span></span><br><span class="line"><span class="keyword">delete</span> [] obj2; <span class="comment">// delete object array.</span></span><br></pre></td></tr></table></figure><p>如果对数组形式做 <code>typedef</code> 动作尤为要注意。</p><h2 id="条款-17-独立语句将-newed-对象放置智能指针"><a href="#条款-17-独立语句将-newed-对象放置智能指针" class="headerlink" title="条款 17 独立语句将 newed 对象放置智能指针"></a>条款 17 独立语句将 newed 对象放置智能指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><p>C++ 并无规定参数执行顺序，以上语句可能有如下顺序：</p><ol><li>执行 <code>new Widget</code></li><li>执行 <code>priority()</code></li><li>调用 <code>shared_ptr</code> 构造函数</li></ol><p>如果 2 中发生异常，3执行不了，就会造成资源泄露。</p><p>解决办法：</p><p>拆分语句，手动确定上述顺序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> priority = <span class="built_in">priority</span>();</span><br><span class="line"><span class="built_in">processWidget</span>(shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority);</span><br></pre></td></tr></table></figure><h2 id="条款-18-接口设计"><a href="#条款-18-接口设计" class="headerlink" title="条款 18 接口设计"></a>条款 18 接口设计</h2><p>接口应易于使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="keyword">int</span> month, <span class="keyword">int</span> day, <span class="keyword">int</span> year);</span><br><span class="line"><span class="built_in">Date</span>(<span class="keyword">const</span> Month&amp; month, <span class="keyword">const</span> Day&amp; day, <span class="keyword">const</span> Year&amp; year);</span><br></pre></td></tr></table></figure><p>前者至少有两个问题，容易以错误次序传递参数；容易传递无效参数。</p><p>可以通过导入新类型预防此类问题，如后者。</p><p>预防客户端错误的另一个方法是限制类型内什么事可做，什么不可做。常见的限制是加上 <code>const</code>.</p><p><strong>避免类型的行为与内置类型不一致</strong>，除非有不得不做的理由。</p><h2 id="条款-19-设计-class"><a href="#条款-19-设计-class" class="headerlink" title="条款 19 设计 class"></a>条款 19 设计 class</h2><p>规范：</p><ul><li><p>对象如何创建和销毁</p></li><li><p>初始化和赋值的区别</p></li><li><p><code>passed by value</code> 意味着什么</p></li><li><p>什么是新 type 的合法值</p></li><li><p>需要继承吗</p></li><li><p>与其他类型之间的转换</p></li><li><p>需要什么样的操作符和函数</p></li><li><p>哪些函数是不需要的（设为 private)</p></li><li><p>一般化，是否需要 <code>template</code></p></li></ul><h2 id="条款-20-pass-by-reference-to-const"><a href="#条款-20-pass-by-reference-to-const" class="headerlink" title="条款 20 pass-by-reference-to-const"></a>条款 20 <code>pass-by-reference-to-const</code></h2><p><code>pass-by-reference-to-const</code> 方式效率较高，因为没有任何新对象被创建。<code>const</code> 保证传入的参数不被改变。</p><p>当把一个派生类对象赋给一个基类对象时，会发生 <strong>对象切割</strong>。当一个 <code>derived class</code> 对象以 by value 方式传递并视为一个 <code>base class</code> 对象时，<code>base class</code> 的 copy 构造函数会被调用，<code>derived class</code>部分会被切割掉。</p><p>传引用可以避免对象切割问题。</p><p>对于内置类型、STL的迭代器和函数对象，<code>pass-by-value</code> 比较适当。</p><blockquote><p>大部分迭代器都是比较小的，复制构造函数一般也只是平凡复制，复制开销并不大，反倒传引用因为经常需要间接访问所以影响性能。</p></blockquote><h2 id="条款-21-函数返回引用"><a href="#条款-21-函数返回引用" class="headerlink" title="条款 21 函数返回引用"></a>条款 21 函数返回引用</h2><p>函数盲目地返回引用可能会导致程序错误或内存泄露。</p><p>将一个函数内部的变量（on stack)通过传引用的方式返回会导致函数返回前变量已经析构。</p><p>在 heap 新建变量并返回引用，容易忘记析构，造成内存泄露。</p><h2 id="条款-22-成员变量私有化"><a href="#条款-22-成员变量私有化" class="headerlink" title="条款 22 成员变量私有化"></a>条款 22 成员变量私有化</h2><p>将成员变量设置为 <code>private</code> 可以更精确地控制对成员变量的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessLevels</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getReadOnly</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> readOnly;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; readWrite = value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getReadWrite</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> readWrite;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; writeOnly = value;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> noAccess;</span><br><span class="line">    <span class="keyword">int</span> readOnly;</span><br><span class="line">    <span class="keyword">int</span> readWrite;</span><br><span class="line">    <span class="keyword">int</span> writeOnly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数来访问成员变量，日后可以改变成员变量而不会对 class 的使用者造成影响。</p><h2 id="条款-23-non-member、non-friend-函数替换-member-函数"><a href="#条款-23-non-member、non-friend-函数替换-member-函数" class="headerlink" title="条款 23 non-member、non-friend 函数替换 member 函数"></a>条款 23 non-member、non-friend 函数替换 member 函数</h2><p>在许多方面，member 函数带来的封装性低于 non-member 函数。</p><h2 id="条款-24-若所有参数皆需要类型转换，采用-non-member-函数"><a href="#条款-24-若所有参数皆需要类型转换，采用-non-member-函数" class="headerlink" title="条款 24 若所有参数皆需要类型转换，采用 non-member 函数"></a>条款 24 若所有参数皆需要类型转换，采用 non-member 函数</h2><h2 id="条款-25-考虑写一个不抛异常的-swap"><a href="#条款-25-考虑写一个不抛异常的-swap" class="headerlink" title="条款 25 考虑写一个不抛异常的 swap"></a>条款 25 考虑写一个不抛异常的 <code>swap</code></h2><h2 id="条款-26-尽可能延后变量定义的时间"><a href="#条款-26-尽可能延后变量定义的时间" class="headerlink" title="条款 26 尽可能延后变量定义的时间"></a>条款 26 尽可能延后变量定义的时间</h2><p>变量定义可能会有构造函数和析构函数的成本。或许你认为你不可能定义一个不使用的变量，但须考虑到异常。</p><p>还要尽可能减少构造函数的开销，比如先构造再赋值不如直接用值构造。</p><h2 id="条款-27-尽量减少转型"><a href="#条款-27-尽量减少转型" class="headerlink" title="条款 27 尽量减少转型"></a>条款 27 尽量减少转型</h2><p>C++ 提供四种新式转型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li>cosnt_cast 移除变量的常量特性.T必须是指针或引用。</li><li>dynamic_cast  在执行期进行多态类(有虚函数)之间的转换,用于运行时类型识别.T必须是指针或引用,expression必须返回多态类类型.。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</li><li>reinterpret_cast 变量二进制位层次上的重新解释,并没有对变量的二进制储存方式进行更改.T 必须是指针,引用或算术类型。</li><li>static_cast 可以执行大多数类型的转换。但与 const_cast 类型相比,static_cast 不能去除 const 或 volatile 属性,与 dynamic_cast 相比不支持运行时类型识别,与 reinterpret_cast 相比不是位层次上的重新解释,而是对位进行改变后的重新编码.</li></ul><h2 id="条款-30-了解-inline"><a href="#条款-30-了解-inline" class="headerlink" title="条款 30 了解 inline"></a>条款 30 了解 <code>inline</code></h2><p>Inline 函数看起来像函数，动作像函数，比宏好得多，调用时没有函数调用时额外开销。inline 函数的观念是，“对函数的每个调用”都以函数本体替换之。这样可能增加代码的大小。</p><p><code>inline</code> 造成的代码膨胀会导致额外的换页行为，降低 cache 的命中率，带来效率损失。</p><p>但如果 <code>inline</code> 函数的本体很小，将函数 inlining 可能会导致更小的代码和更高的 cache 命中率。</p><p><code>inline</code> 只是一个申请，编译器不一定响应。大部分编译器拒绝 <code>inline</code> 太过复杂的函数。</p><p><code>inline</code> 对 virtual 函数无效。</p><p>某个类的构造函数看起来是空的，使用 inline 合适，其实是错误的想法；<br>C++的对象在被创建和销毁时：创建一个对象，每个 base class 及每个成员会自动构造；销毁一个对象时，反向进行析构及销毁；如果遇到异常，编译器尝试的模板代码更多；一旦被 inlined，所有子类都要插入 base class 构造函数的所有自动生成的代码，急速膨胀。 </p><p>inline 函数无法随着程序库的升级而升级。如果重写了 inline 函数，必须重写编译。</p><h2 id="条款-48-初涉模板元编程"><a href="#条款-48-初涉模板元编程" class="headerlink" title="条款 48 初涉模板元编程"></a>条款 48 初涉模板元编程</h2><p>模板元编程(TMP) 是编写 template-based C++ 程序并执行于编译期的过程。</p><p>模板元编程使得某些困难甚至不可能的事情变得容易。由于模板元编程执行于 C++ 编译期，因此可以将某些运行期才能检测到的错误提前检测出来。另外，使用模板元编程的 C++ 程序有较小的可执行文件、较短的运行期、较少的内存需求。缺点是增加了编译时间。</p><h2 id="条款-49-了解-new-handler"><a href="#条款-49-了解-new-handler" class="headerlink" title="条款 49 了解 new-handler"></a>条款 49 了解 new-handler</h2><p>当 <code>operator new</code> 无法进行内存分配，就会抛异常。在抛异常前，会调用错误处理函数，<code>new_handler</code>。客户可以通过调用 <code>set_new_handler</code> 定制这个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set_new_handler</code> 的参数是一个指针，指向无法分配足够内存时调用的函数，返回一个指针，指向被替换的 new-handler 函数。</p><p>好的 <code>new-handler</code> 应该：</p><ul><li><p>让更多内存被使用</p></li><li><p>安装另一个 new-handler</p></li><li><p>卸除 new-handler</p></li><li><p>抛出 <code>bad_alloc</code></p></li><li><p>不返回，通常 <code>abort</code> 或 <code>exit</code>.</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/2021/10/29/hello/"/>
      <url>/2021/10/29/hello/</url>
      
        <content type="html"><![CDATA[<h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1><p>This is a simple page.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
