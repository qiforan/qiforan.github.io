<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向对象与基于对象</title>
      <link href="/2021/11/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/11/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Thread</span>();</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Thread</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HEXO简易使用</title>
      <link href="/2021/11/15/HEXO%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/11/15/HEXO%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一款基于 <code>Node.js</code> 的静态博客框架。</p><span id="more"></span><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发布新文章在 <span class="built_in">source</span>/_posts</span></span><br><span class="line">hexo new &lt;new-post&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地预览</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="next-主题"><a href="#next-主题" class="headerlink" title="next 主题"></a>next 主题</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 常见问题</title>
      <link href="/2021/11/04/Git-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/04/Git-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li>合并最近两次提交为一次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HEAD回退两次，但工作区和index不变</span></span><br><span class="line">git reset --soft HEAD^^</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新提交</span></span><br><span class="line">git commit -m &quot;commit&quot;</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>删除仓库里的文件(包括index)但工作区保留，即从仓库里移除不该提交的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不再追踪某个文件</span></span><br><span class="line">git rm --cached &lt;file&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再加入.gitignore</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>https</code>与远程仓库交互时又不想每次都输入密码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建文件存储第一次输入的GIT用户名和密码</span></span><br><span class="line">git config credential.helper store</span><br></pre></td></tr></table></figure><ul><li><code>git status</code> 中文显示乱码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure><ul><li>修改远程仓库地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url &lt;repo-name&gt; &lt;repo-addr&gt;</span><br></pre></td></tr></table></figure><ul><li>清空 commit 历史，变成干净的仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Checkout</span></span><br><span class="line">git checkout --orphan latest_branch</span><br><span class="line"><span class="meta">#</span><span class="bash"> Add all the files</span></span><br><span class="line">git add -A</span><br><span class="line"><span class="meta">#</span><span class="bash"> Commit the changes</span></span><br><span class="line">git commit -am &quot;commit message&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Delete the branch</span></span><br><span class="line">git branch -D main</span><br><span class="line"><span class="meta">#</span><span class="bash"> Rename the current branch to main</span></span><br><span class="line">git branch -m main</span><br><span class="line"><span class="meta">#</span><span class="bash"> Finally, force update your repository</span></span><br><span class="line">git push -f origin main</span><br></pre></td></tr></table></figure><ul><li>设置 <code>IdentifyFile</code></li></ul><ol><li><p>设置 <code>~/.ssh/config</code> 中的 host</p></li><li><p>使用 <code>ssh-agent</code>，添加密钥文件 <code>ssh-add</code></p></li></ol><p>ssh 登录默认是不开启 <code>ssh-agent</code> 的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ ssh-add -l</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><ul><li>删除未跟踪文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除 untracked files</span></span><br><span class="line">git clean -f</span><br><span class="line"><span class="meta">#</span><span class="bash"> 连 untracked 的目录也一起删掉</span></span><br><span class="line">git clean -fd</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）</span></span><br><span class="line">git clean -xfd</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删</span></span><br><span class="line">git clean -nxfd</span><br><span class="line">git clean -nf</span><br><span class="line">git clean -nfd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 并发二 线程间共享数据</title>
      <link href="/2021/11/01/C-%E5%B9%B6%E5%8F%91%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/11/01/C-%E5%B9%B6%E5%8F%91%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h1><p>解决恶性条件竞争最简单的办法就是对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来看，修改不是已经完成了，就是还没开始。C++标准库提供很多类似的机制。</p><p>另一个选择是对数据结构和不变量的设计进行修改<span id="more"></span>，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的无锁编程。</p><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>C++ 中通过实例化 <code>std::mutex</code> 创建互斥量实例，通过成员函数 <code>lock()</code> 对互斥量上锁，<code>unlock()</code> 进行解锁。不过，实践中不推荐直接去调用成员函数，调用成员函数就意味着，必须在每个函数出口都要去调用 <code>unlock()</code>，也包括异常的情况。C++ 标准库为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>，在构造时就能提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">std::list&lt;<span class="keyword">int</span>&gt; some_list;    <span class="comment">// 1</span></span><br><span class="line">std::mutex some_mutex;    <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 3</span></span><br><span class="line">  some_list.<span class="built_in">push_back</span>(new_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_contains</span><span class="params">(<span class="keyword">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">find</span>(some_list.<span class="built_in">begin</span>(),some_list.<span class="built_in">end</span>(),value_to_find) != some_list.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当成员函数返回的是保护数据的指针或引用时，会破坏数据。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。这就需要对接口有相当谨慎的设计，要确保互斥量能锁住数据的访问，并且不留后门。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++并发(一)</title>
      <link href="/2021/10/29/C-%E5%B9%B6%E5%8F%91/"/>
      <url>/2021/10/29/C-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="线程管理的基础"><a href="#线程管理的基础" class="headerlink" title="线程管理的基础"></a>线程管理的基础</h3><p>每个程序至少有一个线程：执行 <code>main()</code> 函数的(原始)线程。其余线程有其各自的入口函数。</p><p>使用 C++ 线程库启动线程，可以归结为构造 <code>std::thread</code> 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br></pre></td></tr></table></figure><p>使用 <code>std::thread</code> 类需引入 <code>&lt;thread&gt;</code> 头文件。除了函数，<code>std::thread</code> 也可用其他 <strong>可调用类型</strong> 构造。</p><p>启动线程后，需要明确是要等待线程结束，<span id="more"></span>还是让其自主运行。</p><h4 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h4><p>如果要等待子线程结束，相关的 <code>std::thread</code> 实例需要使用 <code>join()</code>，此时调用线程处于阻塞模式。</p><p><code>join()</code> 执行完成之后，底层线程 id 被设置为0，即 <code>joinable()</code> 变为 <code>false</code>。同时会清理线程相关的存储部分， 这样 <code>std::thread</code> 对象将不再与已经底层线程有任何关联。这意味着，只能对一个线程使用一次 <code>join()</code>;再次调用 <code>join()</code>，将返回 <code>false</code>。</p><p>如果不等待线程，就必须保证线程结束之前，可访问的数据的 <strong>有效性</strong>。很可能线程还没结束，函数已经退出，这时线程函数还持有函数局部变量的指针或引用。下面的代码就展示了这样的一种情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>&amp; i;</span><br><span class="line">  <span class="built_in">func</span>(<span class="keyword">int</span>&amp; i_) : <span class="built_in">i</span>(i_) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> j=<span class="number">0</span> ; j&lt;<span class="number">1000000</span> ; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">do_something</span>(i);           <span class="comment">// 1 潜在访问隐患：悬空引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  my_thread.<span class="built_in">detach</span>();          <span class="comment">// 2 不等待线程结束</span></span><br><span class="line">&#125;                              <span class="comment">// 3 新线程可能还在运行</span></span><br></pre></td></tr></table></figure><h4 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h4><p><code>std::thread</code> 实例对象调用 <code>detach()</code> 会导致线程分离。</p><p>分离子线程意味着与当前线程的连接被断开，子线程成为后台线程，被 C++ 运行时库接管。这意味着不可能再有 <code>std::thread</code> 对象能引用到子线程了。与 <code>join</code> 一样，<code>detach</code> 也只能调用一次，当 <code>detach</code> 以后其 <code>joinable()</code> 为 <code>false</code>。</p><h4 id="std-thread-析构"><a href="#std-thread-析构" class="headerlink" title="std::thread 析构"></a><code>std::thread</code> 析构</h4><p><code>std::thread</code> 对象析构时，会先判断 <code>joinable()</code>，如果可联结，则程序会直接被终止（调用<code>std::terminate()</code>）。</p><p>联结状态：一个 <code>std::thread</code> 对象只可能处于可联结或不可联结两种状态之一。可用 <code>joinable()</code> 函数来判断，即 <code>std::thread</code> 对象是否与某个有效的底层线程关联（内部通过判断线程 id 是否为 0 来实现）。</p><ul><li>可联结(joinable)<ul><li>当线程可运行、己运行或处于阻塞时是可联结的。注意，如果某个底层线程已经执行完任务，但是没有被 join 的话，该线程依然会被认为是一个活动的执行线程，仍然处于 joinable 状态。</li></ul></li></ul><ul><li>不可联结（unjoinable)<ul><li>当不带参构造的 <code>std::thread</code> 对象为不可联结，因为底层线程还没创建。</li><li>己移动的 <code>std::thread</code> 对象为不可联结。因为该对象的底层线程 id 已被设置为 0。</li><li>己调用 join 或 detach 的对象为不可联结状态。因为调用 <code>join()</code> 以后，底层线程己结束，而 <code>detach()</code> 会把<code>std::thread</code> 对象和对应的底层线程之间的连接断开。</li></ul></li></ul><h3 id="传递线程参数"><a href="#传递线程参数" class="headerlink" title="传递线程参数"></a>传递线程参数</h3><p>向 <code>std::thread</code> 构造函数中的可调用对象，或函数传递一个参数很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, std::string <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>需要特别要注意，当指向动态变量的指针作为参数传递给线程的情况，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,std::string <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">(<span class="keyword">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">1024</span>]; <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>,some_param);</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,buffer)</span></span>; <span class="comment">// 2</span></span><br><span class="line">  t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能保证构造函数结束时新线程已经执行，只能保证构造函数完成时线程被安排执行，所以可能 <code>f</code> 函数开始执行时，<code>oops</code> 函数已退出。</p><p>参考：<a href="https://stackoverflow.com/questions/17655880/stdthread-construction-and-execution">std::thread construction and execution</a></p><p>解决方案就是在传递到 <code>std::thread</code> 构造函数之前就将字面值转化为 <code>std::string</code> 对象。</p><p>还可能遇到相反的情况：期望传递一个非常量引用(但这不会被编译)，但整个对象被复制了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  widget_data data;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,data)</span></span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">display_status</span>();</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">process_widget_data</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法是：使用 <code>std::ref</code> 将参数转换成引用的形式，从而可将线程的调用改为以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,std::ref(data))</span></span>;</span><br></pre></td></tr></table></figure><p><code>std::thread</code> 的传参类似 <code>std::bind</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_lengthy_work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work,&amp;my_x)</span></span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这段代码中，新线程将 <code>my_x.do_lengthy_work()</code> 作为线程函数；<code>my_x</code> 的地址①作为指针对象提供给函数。也可以为成员函数提供参数：<code>std::thread</code> 构造函数的第三个参数就是成员函数的第一个参数，以此类推。</p><h3 id="std-thread-移动"><a href="#std-thread-移动" class="headerlink" title="std::thread 移动"></a><code>std::thread</code> 移动</h3><p>每个 <code>std::thread</code> 实例都负责管理一个执行线程。执行线程的所有权可以在多个 <code>std::thread</code> 实例中互相转移，这是依赖于 <code>std::thread</code> 实例的可移动且不可复制性。不可复制保性证了在同一时间点，一个 <code>std::thread</code> 实例只能关联一个执行线程；可移动性使得开发者可以自己决定，哪个实例拥有实际执行线程的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;            <span class="comment">// 1</span></span><br><span class="line">std::thread t2=std::<span class="built_in">move</span>(t1);            <span class="comment">// 2</span></span><br><span class="line">t1=std::<span class="built_in">thread</span>(some_other_function);    <span class="comment">// 3</span></span><br><span class="line">std::thread t3;                            <span class="comment">// 4</span></span><br><span class="line">t3=std::<span class="built_in">move</span>(t2);                        <span class="comment">// 5</span></span><br><span class="line">t1=std::<span class="built_in">move</span>(t3);                        <span class="comment">// 6 赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure><p>为了确保线程程序退出前完成，下面的代码里定义了 <code>scoped_thread</code>类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scoped_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread t_)</span>:                 // <span class="number">1</span></span></span><br><span class="line"><span class="function">    t(std::move(t_))</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!t.<span class="built_in">joinable</span>())                                     <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“No thread”);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();                                            <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scoped_thread</span>(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  scoped_thread&amp; <span class="keyword">operator</span>=(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state;</span><br><span class="line">  <span class="function">scoped_thread <span class="title">t</span><span class="params">(std::thread(func(some_local_state)))</span></span>;    <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125;                                                        <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="决定线程数量"><a href="#决定线程数量" class="headerlink" title="决定线程数量"></a>决定线程数量</h3><h3 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h3><p>线程标识类型为 <code>std::thread::id</code>，并可以通过两种方式进行检索。第一种，可以通过调用 <code>std::thread</code> 对象的成员函数 <code>get_id()</code> 来直接获取。如果 <code>std::thread</code> 对象没有与任何执行线程相关联，<code>get_id()</code> 将返回 <code>std::thread::type</code> 默认构造值，这个值表示“无线程”。第二种，当前线程中调用 <code>std::this_thread::get_id()</code> (这个函数定义在<thread>头文件中)也可以获得线程标识。</p><p><code>std::thread::id</code> 对象可以自由的拷贝和对比,因为标识符就可以复用。如果两个对象的 <code>std::thread::id</code> 相等，那它们就是同一个线程，或者都“无线程”。如果不等，那么就代表了两个不同线程，或者一个有线程，另一没有线程。</p><p>这意味着允许程序员将其当做为容器的键值，做排序，或做其他方式的比较。</p><p>也可以使用输出流( <code>std::cout</code> )来记录一个 <code>std::thread::id</code> 对象的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;std::this_thread::<span class="built_in">get_id</span>();</span><br></pre></td></tr></table></figure><p>具体的输出结果是严格依赖于具体实现的，C++标准的唯一要求就是要保证ID比较结果相等的线程，必须有相同的输出。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 笔记</title>
      <link href="/2021/10/29/cpp-effective/"/>
      <url>/2021/10/29/cpp-effective/</url>
      
        <content type="html"><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>声明式(declaration)</strong> 告诉编译器名称和类型，略去细节。 函数的声明揭示了其签名，包括其参数和返回值。</p><p><strong>定义式(definition)</strong> 提供了声明里遗漏的细节，并分配内存。对函数而言，定义提供了代码本体。</p><p><strong>初始化(initilazation)</strong> 给对象赋初值。</p><p>声明和定义可以同时进行<span id="more"></span>。</p><h2 id="条款-1"><a href="#条款-1" class="headerlink" title="条款 1"></a>条款 1</h2><p>C++ 是一个多重范型编程语言，支持过程形式、面向对象形式、函数形式、范型形式、元编程形式的语言。</p><h2 id="条款-2"><a href="#条款-2" class="headerlink" title="条款 2"></a>条款 2</h2><p>由 <code>define</code> 定义的常量会在预处理时替换，不会进入记号表（symbol table)，不利于调试。</p><p>解决方式是用 <code>const</code> 常量替换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure><p><code>const</code> 对象默认仅在文件内有效。</p><p><strong>注意</strong>：</p><ol><li>由于常量定义式被放在头文件内，因此定义常量指针时，要将指针声明为 <code>const</code>.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">&quot;Scott Meyers&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>若为 class 内的常量，应设置为 <code>static</code>, 保证只有一个实体。 </li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>; <span class="comment">// 常量声明式，可以不需要定义式</span></span><br><span class="line">    <span class="keyword">int</span> socres[NumTurns];          <span class="comment">// 使用该常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>static</code> 且为整型的类变量，如上面的 <code>NumTurns</code>，可以不需要提供定义式。</p><p>关于 <code>NumTurns</code> 的疑问，参考:</p><ul><li><p><a href="https://www.stroustrup.com/bs_faq2.html#in-class">How do I define an in-class constant?</a></p></li><li><p><a href="https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration">What is the difference between a definition and a declaration?</a></p></li><li><p><a href="https://stackoverflow.com/questions/34629876/why-is-declaration-and-definition-defined-this-way-in-effective-c">why static const int NumTurns = 5; is not a definition?</a></p></li><li><p><a href="https://stackoverflow.com/questions/34629876/why-is-declaration-and-definition-defined-this-way-in-effective-c">Why is declaration and definition defined this way in Effective C++?</a></p></li></ul><p>一个属于枚举类型(enumerated type) 的数值可充当 <code>ints</code> 使用，但无法被取地址，如果不想指针指向你的整数常量，可使用     <code>enum</code>.</p><blockquote><p>一个属于枚举类型的数值可充当 <code>ints</code> 使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>NumTurns = <span class="number">5</span>&#125;;           <span class="comment">// </span></span><br><span class="line">    <span class="keyword">int</span> socres[NumTurns];          <span class="comment">// 使用该常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想获得 <code>define</code> 实现宏的效果（减少函数调用），可以使用 <code>template inline</code>.</p><h2 id="条款-3-尽可能使用-const"><a href="#条款-3-尽可能使用-const" class="headerlink" title="条款 3 尽可能使用 const"></a>条款 3 尽可能使用 <code>const</code></h2><p><code>const</code> 可以修饰全局变量，也可以修饰文件、函数等。</p><p>如果 <code>const</code> 修饰指针变量，则</p><ul><li><p><code>const</code> 出现在星号左边，表示被指物是常量；</p></li><li><p><code>const</code> 出现在星号右边，表示指针自身是常量，其指向不可变；</p></li></ul><p>令函数返回一个常量，可以减少不恰当使用造成的问题，如错把 <code>==</code> 当 <code>=</code>.</p><p>把某些成员函数限定为 <code>const</code>, 一来更易理解函数的含义，二来通过“操作 const 对象”可以改善代码效率，参考 条款 20.</p><p>添加 <code>const</code> 属性可以导致重载，包括给参数添加 <code>const</code>.</p><h2 id="条款-4-构造函数与初始化"><a href="#条款-4-构造函数与初始化" class="headerlink" title="条款 4 构造函数与初始化"></a>条款 4 构造函数与初始化</h2><p>永远在使用对象之前初始化。对于内置类型，需要手工完成。对于对象，确保构造函数将对象每一个成员初始化。</p><p>构造函数中，容易混淆 <strong>赋值</strong> 和 <strong>初始化</strong>.</p><p>对象成员非内置类型变量的初始化动作发生在进入构造函数本体 <strong>之前</strong>。</p><p>一个较好的写法是，使用 <code>member initialization list</code> 替换赋值动作。</p><p>C++ 成员初始化次序比较固定：</p><ol><li><code>base classes</code> 早于 <code>derived classes</code> 被初始化。</li><li>class 的成员变量总是以其声明的顺序被初始化。</li></ol><p>static 对象生命周期从构造出来开始直至程序结束。这种对象包括 global 对象，定义于 namespace 作用域内的对象、在 classes 内、在函数内、在 file 作用域内被声明为 <code>static</code> 的对象。其中，函数内的 static 对象被称为 <code>local static 对象</code>，其他被称为 <code>non-local static 对象</code>.</p><h2 id="条款-5-默认生成的构造函数"><a href="#条款-5-默认生成的构造函数" class="headerlink" title="条款 5 默认生成的构造函数"></a>条款 5 默认生成的构造函数</h2><p>一个类必须有默认构造函数、copy 构造函数、copy 赋值操作符、析构函数，如果没有显式声明，编译器会隐式声明，且都是 <code>public &amp; inline</code>.</p><p>编译器生成的默认构造函数或析构函数只会调用基类构造函数或析构函数、non-static 成员变量的构造函数或析构函数。</p><p>对于 copy 构造函数和 copy 赋值操作符，编译器创建的版本只是把来源对象中的每一个 non-static 成员变量拷贝到目标对象。</p><p>编译器构造出来的  copy 赋值操作符需合法且有意义。如果一个类的成员有引用的话，则需要自定义 copy 赋值操作符。</p><h2 id="条款-6-拒绝编译器生成的函数"><a href="#条款-6-拒绝编译器生成的函数" class="headerlink" title="条款 6 拒绝编译器生成的函数"></a>条款 6 拒绝编译器生成的函数</h2><p>为了阻止编译器自动生成的函数（条款 5），可以手动将其声明为 <code>private</code> 并不予实现。也可以 private 继承 <code>Uncopyable</code>.</p><h2 id="条款-7-基类析构函数为-virtual"><a href="#条款-7-基类析构函数为-virtual" class="headerlink" title="条款 7 基类析构函数为 virtual"></a>条款 7 基类析构函数为 virtual</h2><p>当 derived class 对象由一个 base class 指针删除时，如果 base class 的析构函数为 non-virtual，其行为是未定义的，即可能 对象中 derived 成分没有被销毁，造成资源泄露。</p><p>解决办法:</p><p>设置 base class 析构函数为 virtual。</p><p>注意：</p><p>将所有 class 的析构函数声明为 virtual 是错误的，这会增大 class 的体积。常见的做法是，当 class 内至少含一个 virtual 函数，才声明 virtual 析构函数。</p><p>给 base class 一个 virtual 析构函数只适用 polymorphic base class 身上。</p><h2 id="条款-8-析构函数与异常"><a href="#条款-8-析构函数与异常" class="headerlink" title="条款 8 析构函数与异常"></a>条款 8 析构函数与异常</h2><p>析构函数最好不要抛出异常。原因：</p><ol><li><p>抛出异常后的代码不会执行，可能会造成资源泄露。</p></li><li><p>在异常的传播过程中进行栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。</p></li></ol><p>解决办法：</p><ol><li><p>如果异常出现在析构函数里，应该捕捉异常，而不是抛出异常。</p></li><li><p>异常处理应该出现在普通函数而非析构函数。</p></li></ol><h2 id="条款-9-构造函数和析构函数不调用-virtual-函数"><a href="#条款-9-构造函数和析构函数不调用-virtual-函数" class="headerlink" title="条款 9 构造函数和析构函数不调用 virtual 函数"></a>条款 9 构造函数和析构函数不调用 virtual 函数</h2><ul><li><p>不要在构造函数中调用虚函数的原因：因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化， 因此调用子类的虚函数是不安全的，故而C++不会进行动态联编。</p></li><li><p>不要在析构函数中调用虚函数的原因：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</p></li></ul><h2 id="条款-10-operator-返回-reference-to-this"><a href="#条款-10-operator-返回-reference-to-this" class="headerlink" title="条款 10 operator = 返回 reference to *this"></a>条款 10 <code>operator =</code> 返回 reference to *this</h2><p>为了实现 <strong>连锁赋值</strong>，赋值操作符必须返回一个 reference 指向操作符的左侧实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/22821783">c++中有些重载运算符为什么要返回引用？</a></p><h2 id="条款-11-operator-处理自我赋值"><a href="#条款-11-operator-处理自我赋值" class="headerlink" title="条款 11 operator= 处理自我赋值"></a>条款 11 <code>operator=</code> 处理自我赋值</h2><p>自我赋值可能出现问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    Bitmap *pb;</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>*this</code> 和 <code>rhs</code> 是同一个对象，就会出现指针指向一个被删除的对象。</p><p>解决办法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 证同测试，identity test</span></span><br></pre></td></tr></table></figure><p>这样只解决了部分问题：不是异常安全的，如果 <code>new</code> 发生了异常，指针仍指向一块被删除的对象。</p><p>调换 <code>new</code> 和 <code>delete</code> 的先后顺序可以解决问题，唯一的问题是如果 <code>*this</code> 和 <code>rhs</code> 相同时会有效率问题。</p><h2 id="条款-12-复制对象勿忘了每一个成分"><a href="#条款-12-复制对象勿忘了每一个成分" class="headerlink" title="条款 12 复制对象勿忘了每一个成分"></a>条款 12 复制对象勿忘了每一个成分</h2><p>手动实现 copy 复制构造函数时，不要忘了每一个成分：当添加一个成员变量时，同时修改函数。如果忘记，编译器并不会提醒你。</p><p>不要忘记复制 base class 的成分。</p><h2 id="条款-13-对象管理资源"><a href="#条款-13-对象管理资源" class="headerlink" title="条款 13 对象管理资源"></a>条款 13 对象管理资源</h2><p>把资源放入对象中，便可以倚赖 <strong>析构函数</strong> 自动调用机制确保资源被释放。</p><p>两个常用的 RAII classes 是 <code>shared_ptr</code> 和 <code>unique_ptr</code>。</p><h2 id="条款-14-资源管理类小心-copy"><a href="#条款-14-资源管理类小心-copy" class="headerlink" title="条款 14 资源管理类小心 copy"></a>条款 14 资源管理类小心 copy</h2><p>处理 RAII 类的复制，一般有两种情况：</p><ol><li><p>禁止复制</p></li><li><p>使用引用计数</p></li></ol><h2 id="条款-15-RAII-类应该提供对原始资源的访问接口"><a href="#条款-15-RAII-类应该提供对原始资源的访问接口" class="headerlink" title="条款 15 RAII 类应该提供对原始资源的访问接口"></a>条款 15 RAII 类应该提供对原始资源的访问接口</h2><p>许多 API 直接处理原始资源，因此需要将 RAII 对象转换为原始资源。</p><p>显示转换：提供 <code>get()</code> 函数。</p><p>隐式转换：重载操作符（<code>*</code>,<code>-&gt;</code>,<code>conversion operator</code>)。</p><p><a href="https://stackoverflow.com/questions/19666392/what-is-operator-class-name-const">what is operator class_name() const?</a></p><p>显式转换较为麻烦，隐式转换可能会增加错误发生的机会。</p><h2 id="条款-16-delete-数组"><a href="#条款-16-delete-数组" class="headerlink" title="条款 16 delete 数组"></a>条款 16 delete 数组</h2><p>删除指针所指空间除了会归还空间，会先调用析构函数。问题是被删除的指针可能指向单个对象，也可能指向对象数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj1; <span class="comment">// delete one object</span></span><br><span class="line"><span class="keyword">delete</span> [] obj2; <span class="comment">// delete object array.</span></span><br></pre></td></tr></table></figure><p>如果对数组形式做 <code>typedef</code> 动作尤为要注意。</p><h2 id="条款-17-独立语句将-newed-对象放置智能指针"><a href="#条款-17-独立语句将-newed-对象放置智能指针" class="headerlink" title="条款 17 独立语句将 newed 对象放置智能指针"></a>条款 17 独立语句将 newed 对象放置智能指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><p>C++ 并无规定参数执行顺序，以上语句可能有如下顺序：</p><ol><li>执行 <code>new Widget</code></li><li>执行 <code>priority()</code></li><li>调用 <code>shared_ptr</code> 构造函数</li></ol><p>如果 2 中发生异常，3执行不了，就会造成资源泄露。</p><p>解决办法：</p><p>拆分语句，手动确定上述顺序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> priority = <span class="built_in">priority</span>();</span><br><span class="line"><span class="built_in">processWidget</span>(shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority);</span><br></pre></td></tr></table></figure><h2 id="条款-18-接口设计"><a href="#条款-18-接口设计" class="headerlink" title="条款 18 接口设计"></a>条款 18 接口设计</h2><p>接口应易于使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="keyword">int</span> month, <span class="keyword">int</span> day, <span class="keyword">int</span> year);</span><br><span class="line"><span class="built_in">Date</span>(<span class="keyword">const</span> Month&amp; month, <span class="keyword">const</span> Day&amp; day, <span class="keyword">const</span> Year&amp; year);</span><br></pre></td></tr></table></figure><p>前者至少有两个问题，容易以错误次序传递参数；容易传递无效参数。</p><p>可以通过导入新类型预防此类问题，如后者。</p><p>预防客户端错误的另一个方法是限制类型内什么事可做，什么不可做。常见的限制是加上 <code>const</code>.</p><p><strong>避免类型的行为与内置类型不一致</strong>，除非有不得不做的理由。</p><h2 id="条款-19-设计-class"><a href="#条款-19-设计-class" class="headerlink" title="条款 19 设计 class"></a>条款 19 设计 class</h2><p>规范：</p><ul><li><p>对象如何创建和销毁</p></li><li><p>初始化和赋值的区别</p></li><li><p><code>passed by value</code> 意味着什么</p></li><li><p>什么是新 type 的合法值</p></li><li><p>需要继承吗</p></li><li><p>与其他类型之间的转换</p></li><li><p>需要什么样的操作符和函数</p></li><li><p>哪些函数是不需要的（设为 private)</p></li><li><p>一般化，是否需要 <code>template</code></p></li></ul><h2 id="条款-20-pass-by-reference-to-const"><a href="#条款-20-pass-by-reference-to-const" class="headerlink" title="条款 20 pass-by-reference-to-const"></a>条款 20 <code>pass-by-reference-to-const</code></h2><p><code>pass-by-reference-to-const</code> 方式效率较高，因为没有任何新对象被创建。<code>const</code> 保证传入的参数不被改变。</p><p>当把一个派生类对象赋给一个基类对象时，会发生 <strong>对象切割</strong>。当一个 <code>derived class</code> 对象以 by value 方式传递并视为一个 <code>base class</code> 对象时，<code>base class</code> 的 copy 构造函数会被调用，<code>derived class</code>部分会被切割掉。</p><p>传引用可以避免对象切割问题。</p><p>对于内置类型、STL的迭代器和函数对象，<code>pass-by-value</code> 比较适当。</p><blockquote><p>大部分迭代器都是比较小的，复制构造函数一般也只是平凡复制，复制开销并不大，反倒传引用因为经常需要间接访问所以影响性能。</p></blockquote><h2 id="条款-21-函数返回引用"><a href="#条款-21-函数返回引用" class="headerlink" title="条款 21 函数返回引用"></a>条款 21 函数返回引用</h2><p>函数盲目地返回引用可能会导致程序错误或内存泄露。</p><p>将一个函数内部的变量（on stack)通过传引用的方式返回会导致函数返回前变量已经析构。</p><p>在 heap 新建变量并返回引用，容易忘记析构，造成内存泄露。</p><h2 id="条款-22-成员变量私有化"><a href="#条款-22-成员变量私有化" class="headerlink" title="条款 22 成员变量私有化"></a>条款 22 成员变量私有化</h2><p>将成员变量设置为 <code>private</code> 可以更精确地控制对成员变量的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessLevels</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getReadOnly</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> readOnly;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; readWrite = value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getReadWrite</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> readWrite;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; writeOnly = value;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> noAccess;</span><br><span class="line">    <span class="keyword">int</span> readOnly;</span><br><span class="line">    <span class="keyword">int</span> readWrite;</span><br><span class="line">    <span class="keyword">int</span> writeOnly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数来访问成员变量，日后可以改变成员变量而不会对 class 的使用者造成影响。</p><h2 id="条款-23-non-member、non-friend-函数替换-member-函数"><a href="#条款-23-non-member、non-friend-函数替换-member-函数" class="headerlink" title="条款 23 non-member、non-friend 函数替换 member 函数"></a>条款 23 non-member、non-friend 函数替换 member 函数</h2><p>在许多方面，member 函数带来的封装性低于 non-member 函数。</p><h2 id="条款-24-若所有参数皆需要类型转换，采用-non-member-函数"><a href="#条款-24-若所有参数皆需要类型转换，采用-non-member-函数" class="headerlink" title="条款 24 若所有参数皆需要类型转换，采用 non-member 函数"></a>条款 24 若所有参数皆需要类型转换，采用 non-member 函数</h2><h2 id="条款-25-考虑写一个不抛异常的-swap"><a href="#条款-25-考虑写一个不抛异常的-swap" class="headerlink" title="条款 25 考虑写一个不抛异常的 swap"></a>条款 25 考虑写一个不抛异常的 <code>swap</code></h2><h2 id="条款-26-尽可能延后变量定义的时间"><a href="#条款-26-尽可能延后变量定义的时间" class="headerlink" title="条款 26 尽可能延后变量定义的时间"></a>条款 26 尽可能延后变量定义的时间</h2><p>变量定义可能会有构造函数和析构函数的成本。或许你认为你不可能定义一个不使用的变量，但须考虑到异常。</p><p>还要尽可能减少构造函数的开销，比如先构造再赋值不如直接用值构造。</p><h2 id="条款-27-尽量减少转型"><a href="#条款-27-尽量减少转型" class="headerlink" title="条款 27 尽量减少转型"></a>条款 27 尽量减少转型</h2><p>C++ 提供四种新式转型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li>cosnt_cast 移除变量的常量特性.T必须是指针或引用。</li><li>dynamic_cast  在执行期进行多态类(有虚函数)之间的转换,用于运行时类型识别.T必须是指针或引用,expression必须返回多态类类型.。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</li><li>reinterpret_cast 变量二进制位层次上的重新解释,并没有对变量的二进制储存方式进行更改.T 必须是指针,引用或算术类型。</li><li>static_cast 可以执行大多数类型的转换。但与 const_cast 类型相比,static_cast 不能去除 const 或 volatile 属性,与 dynamic_cast 相比不支持运行时类型识别,与 reinterpret_cast 相比不是位层次上的重新解释,而是对位进行改变后的重新编码.</li></ul><h2 id="条款-30-了解-inline"><a href="#条款-30-了解-inline" class="headerlink" title="条款 30 了解 inline"></a>条款 30 了解 <code>inline</code></h2><p>Inline 函数看起来像函数，动作像函数，比宏好得多，调用时没有函数调用时额外开销。inline 函数的观念是，“对函数的每个调用”都以函数本体替换之。这样可能增加代码的大小。</p><p><code>inline</code> 造成的代码膨胀会导致额外的换页行为，降低 cache 的命中率，带来效率损失。</p><p>但如果 <code>inline</code> 函数的本体很小，将函数 inlining 可能会导致更小的代码和更高的 cache 命中率。</p><p><code>inline</code> 只是一个申请，编译器不一定响应。大部分编译器拒绝 <code>inline</code> 太过复杂的函数。</p><p><code>inline</code> 对 virtual 函数无效。</p><p>某个类的构造函数看起来是空的，使用 inline 合适，其实是错误的想法；<br>C++的对象在被创建和销毁时：创建一个对象，每个 base class 及每个成员会自动构造；销毁一个对象时，反向进行析构及销毁；如果遇到异常，编译器尝试的模板代码更多；一旦被 inlined，所有子类都要插入 base class 构造函数的所有自动生成的代码，急速膨胀。 </p><p>inline 函数无法随着程序库的升级而升级。如果重写了 inline 函数，必须重写编译。</p><h2 id="条款-48-初涉模板元编程"><a href="#条款-48-初涉模板元编程" class="headerlink" title="条款 48 初涉模板元编程"></a>条款 48 初涉模板元编程</h2><p>模板元编程(TMP) 是编写 template-based C++ 程序并执行于编译期的过程。</p><p>模板元编程使得某些困难甚至不可能的事情变得容易。由于模板元编程执行于 C++ 编译期，因此可以将某些运行期才能检测到的错误提前检测出来。另外，使用模板元编程的 C++ 程序有较小的可执行文件、较短的运行期、较少的内存需求。缺点是增加了编译时间。</p><h2 id="条款-49-了解-new-handler"><a href="#条款-49-了解-new-handler" class="headerlink" title="条款 49 了解 new-handler"></a>条款 49 了解 new-handler</h2><p>当 <code>operator new</code> 无法进行内存分配，就会抛异常。在抛异常前，会调用错误处理函数，<code>new_handler</code>。客户可以通过调用 <code>set_new_handler</code> 定制这个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set_new_handler</code> 的参数是一个指针，指向无法分配足够内存时调用的函数，返回一个指针，指向被替换的 new-handler 函数。</p><p>好的 <code>new-handler</code> 应该：</p><ul><li><p>让更多内存被使用</p></li><li><p>安装另一个 new-handler</p></li><li><p>卸除 new-handler</p></li><li><p>抛出 <code>bad_alloc</code></p></li><li><p>不返回，通常 <code>abort</code> 或 <code>exit</code>.</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/2021/10/29/hello/"/>
      <url>/2021/10/29/hello/</url>
      
        <content type="html"><![CDATA[<h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1><p>This is a simple page.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
